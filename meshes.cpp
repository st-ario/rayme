#include "meshes.h"
#include "extern/glm/glm/gtx/norm.hpp"

hit_record triangle::get_record(const ray& r, float at) const
{
  const point& p0 = parent_mesh->vertices[parent_mesh->vertex_indices[3*number]];
  const point& p1 = parent_mesh->vertices[parent_mesh->vertex_indices[3*number+1]];
  const point& p2 = parent_mesh->vertices[parent_mesh->vertex_indices[3*number+2]];

  vec3 nonunital_candidate_normal = cross(p1-p0, p2-p0);

  bool front_face = dot(r.direction, nonunital_candidate_normal) < 0;

  normed_vec3 normal = front_face ? unit(nonunital_candidate_normal) : - unit(nonunital_candidate_normal);

  return hit_record(at, front_face, parent_mesh->ptr_mat, normal);
}

aabb triangle::bounding_box() const
{
  float padding = 0.001f;
  const point& p0 = parent_mesh->vertices[parent_mesh->vertex_indices[3*number]];
  const point& p1 = parent_mesh->vertices[parent_mesh->vertex_indices[3*number+1]];
  const point& p2 = parent_mesh->vertices[parent_mesh->vertex_indices[3*number+2]];

  float min_x = fminf(p0.x, fminf(p1.x, p2.x)) - padding;
  float min_y = fminf(p0.y, fminf(p1.y, p2.y)) - padding;
  float min_z = fminf(p0.z, fminf(p1.z, p2.z)) - padding;

  float max_x = fmaxf(p0.x, fmaxf(p1.x, p2.x)) + padding;
  float max_y = fmaxf(p0.y, fmaxf(p1.y, p2.y)) + padding;
  float max_z = fmaxf(p0.z, fmaxf(p1.z, p2.z)) + padding;

  return aabb(vec3(min_x, min_y, min_z), vec3(max_x, max_y, max_z));
}

void light::compute_surface_area()
{
  float surface{0.0f};
  triangles_areas.reserve(n_triangles);
  triangles_cdf.reserve(n_triangles);

  float triangle_surface{0.0f};

  for (size_t i = 0; i < n_triangles; ++i)
  {
    const point& p0 = vertices[vertex_indices[3*i]];
    const point& p1 = vertices[vertex_indices[3*i+1]];
    const point& p2 = vertices[vertex_indices[3*i+2]];

    triangle_surface = 0.5f * glm::length(cross(p1 - p0, p2 - p0));
    triangles_areas.push_back(triangle_surface);

    surface += triangle_surface;
    triangles_cdf.push_back(surface);
  }

  surface_area = surface;
}

void world_lights::compute_light_areas()
{
  for (auto& light : lights())
    light->compute_surface_area();
}

point light::random_surface_point() const
{
  // select a triangle with a PDF weighted by the surface of each triangle using the inversion method
  // then return a uniformly distributed point from it

  // binary search to invert the CDF
  float r0{random_float(0.0f,get_surface_area())};

  size_t sel{0};
  size_t len{n_triangles};
  size_t step{0};

  while (len != 0)
  {
    step = len / 2;

    if (triangles_cdf[sel + step] < r0)
    {
      sel += ++step;
      len -= step;
    } else {
      len = step;
    }
  }

  const point& p0 = vertices[vertex_indices[3*sel]];
  const point& p1 = vertices[vertex_indices[3*sel + 1]];
  const point& p2 = vertices[vertex_indices[3*sel + 2]];

  // uniform distribution on a triangle:
  // pick a point uniformly in the parallelogram generated by p1-p0 and p2-po
  // if it's outside the triangle boundaries, reflect it along the diagonal
  float r1{random_float()};
  float r2{random_float()};
  bool outside{r1 + r2 > 1.0f};

  point res = p0;
  res += (outside) ? (1.0f - r1) * (p1-p0) + (1.0f - r2) * (p2-p0) : r1 * (p1-p0) + r2 * (p2-p0);

  return res;
}

hit_check triangle::hit(const ray& r, float t_max) const
{
  // adapted from pbrt v3
  /*
  Copyright (c) 1998-2015, Matt Pharr, Greg Humphreys, and Wenzel Jakob.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification, are permitted
  provided that the following conditions are met:

  Redistributions of source code must retain the above copyright notice, this list of conditions
  and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright notice, this list of
  conditions and the following disclaimer in the documentation and/or other materials provided
  with the distribution.


  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
  */

  const point& p0 = parent_mesh->vertices[parent_mesh->vertex_indices[3*number]];
  const point& p1 = parent_mesh->vertices[parent_mesh->vertex_indices[3*number+1]];
  const point& p2 = parent_mesh->vertices[parent_mesh->vertex_indices[3*number+2]];

  // translate vertices based on ray origin
  point p0t = p0 - r.origin;
  point p1t = p1 - r.origin;
  point p2t = p2 - r.origin;

  // Permute components of triangle vertices and ray direction
  p0t = permute(p0t, r.perm.x, r.perm.y, r.perm.z);
  p1t = permute(p1t, r.perm.x, r.perm.y, r.perm.z);
  p2t = permute(p2t, r.perm.x, r.perm.y, r.perm.z);

  // shear to align ray direction with the Y axis
  p0t.x += r.shear_coefficients.x * p0t.z;
  p0t.y += r.shear_coefficients.y * p0t.z;
  p1t.x += r.shear_coefficients.x * p1t.z;
  p1t.y += r.shear_coefficients.y * p1t.z;
  p2t.x += r.shear_coefficients.x * p2t.z;
  p2t.y += r.shear_coefficients.y * p2t.z;

  // Compute edge function coefficients
  float e0 = p1t.x * p2t.y - p1t.y * p2t.x;
  float e1 = p2t.x * p0t.y - p2t.y * p0t.x;
  float e2 = p0t.x * p1t.y - p0t.y * p1t.x;

  // Fall back to double precision test at triangle edges
  if  (e0 == 0.0f || e1 == 0.0f || e2 == 0.0f)
  {
      double p2txp1ty = (double)p2t.x * (double)p1t.y;
      double p2typ1tx = (double)p2t.y * (double)p1t.x;
      e0 = (float)(p2typ1tx - p2txp1ty);
      double p0txp2ty = (double)p0t.x * (double)p2t.y;
      double p0typ2tx = (double)p0t.y * (double)p2t.x;
      e1 = (float)(p0typ2tx - p0txp2ty);
      double p1txp0ty = (double)p1t.x * (double)p0t.y;
      double p1typ0tx = (double)p1t.y * (double)p0t.x;
      e2 = (float)(p1typ0tx - p1txp0ty);
  }

  // Perform triangle edge and determinant tests
  if ((e0 < 0 || e1 < 0 || e2 < 0) && (e0 > 0 || e1 > 0 || e2 > 0))
    return std::nullopt;
  float det = e0 + e1 + e2;
  if (det == 0) return std::nullopt;

  // Compute scaled hit distance to triangle and test against ray $t$ range
  p0t.z *= r.shear_coefficients.z;
  p1t.z *= r.shear_coefficients.z;
  p2t.z *= r.shear_coefficients.z;
  float tScaled = e0 * p0t.z + e1 * p1t.z + e2 * p2t.z;
  if (det < 0 && (tScaled >= 0 || tScaled < t_max * det))
      return std::nullopt;
  else if (det > 0 && (tScaled <= 0 || tScaled > t_max * det))
      return std::nullopt;

  // Compute barycentric coordinates and $t$ value for triangle intersection
  float invDet = 1 / det;
  float t = tScaled * invDet;

  float b0 = e0 * invDet;
  float b1 = e1 * invDet;
  float b2 = e2 * invDet;

  // Compute $\delta_z$ term for triangle $t$ error bounds
  float maxZt = max_component(abs(vec3(p0t.z, p1t.z, p2t.z)));
  float deltaZ = gamma_bound(3) * maxZt;

  // Compute $\delta_x$ and $\delta_y$ terms for triangle $t$ error bounds
  float maxXt = max_component(abs(vec3(p0t.x, p1t.x, p2t.x)));
  float maxYt = max_component(abs(vec3(p0t.y, p1t.y, p2t.y)));
  float deltaX = gamma_bound(5) * (maxXt + maxZt);
  float deltaY = gamma_bound(5) * (maxYt + maxZt);

  // Compute $\delta_e$ term for triangle $t$ error bounds
  float deltaE = 2 * (gamma_bound(2) * maxXt * maxYt + deltaY * maxXt + deltaX * maxYt);

  // Compute $\delta_t$ term for triangle $t$ error bounds and check _t_
  float maxE = max_component(abs(vec3(e0, e1, e2)));
  float deltaT = 3 * (gamma_bound(3) * maxE * maxZt +
                 deltaE * maxZt + deltaZ * maxE) * std::abs(invDet);
  if (t <= deltaT)
    return std::nullopt;

  // Compute error bounds
  float xAbsSum = (std::abs(b0 * p0.x) + std::abs(b1 * p1.x) + std::abs(b2 * p2.x));
  float yAbsSum = (std::abs(b0 * p0.y) + std::abs(b1 * p1.y) + std::abs(b2 * p2.y));
  float zAbsSum = (std::abs(b0 * p0.z) + std::abs(b1 * p1.z) + std::abs(b2 * p2.z));
  vec3 p_error = gamma_bound(7) * vec3(xAbsSum, yAbsSum, zAbsSum);

  return std::make_tuple(this, t, p_error);
}